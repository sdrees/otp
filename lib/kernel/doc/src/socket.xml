<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE erlref SYSTEM "erlref.dtd">

<erlref>
  <header>
    <copyright>
      <year>2018</year><year>2020</year>
      <holder>Ericsson AB. All Rights Reserved.</holder>
    </copyright>
    <legalnotice>
      Licensed under the Apache License, Version 2.0 (the "License");
      you may not use this file except in compliance with the License.
      You may obtain a copy of the License at
 
          http://www.apache.org/licenses/LICENSE-2.0

      Unless required by applicable law or agreed to in writing, software
      distributed under the License is distributed on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
      See the License for the specific language governing permissions and
      limitations under the License.

    </legalnotice>

    <title>socket</title>
    <prepared></prepared>
    <docno></docno>
    <date></date>
    <rev></rev>
    <file>socket.xml</file>
  </header>
  <module since="OTP 22.0">socket</module>
  <modulesummary>Socket interface.</modulesummary>
  <description>
    <p>This module provides an API for network socket.
    Functions are provided to create, delete and manupilate the sockets
    aswell as sending and reciving data on them. </p>
    <p>The intent is that it shall be as "close as possible" to the OS
    level socket interface. The only significant addition is that some of
    the functions,
    e.g. <seemfa marker="#recv/3"><c>recv/3</c></seemfa>, 
    has a timeout argument. </p>
    <note>
      <p>Some functions allow for an <i>asynchronous</i> call.
      This is achieved by setting the <c>Timeout</c> argument to
      <c>nowait</c>. For instance, if calling the
      <seeerl marker="#recv_async"><c>recv/3</c></seeerl>
      function with Timeout set to <c>nowait</c> (<c>recv(Sock, 0, nowait)</c>)
      when there is actually nothing to read, it will return with
      <c>{select, </c>
      <seetype marker="#select_info"><c>SelectInfo</c></seetype><c>}</c>
      (<c>SelectInfo</c> contains the
      <seetype marker="socket#select_handle">SelectHandle</seetype>).
      When data eventually arrives a 'select' message
      will be sent to the caller: </p>
      <taglist>
	<!-- NOTE THAT THE EMPTY TAG IS INTENTIONAL -->
	<tag></tag>
	<item><c>{'$socket', socket(), select, SelectHandle}</c></item>
      </taglist>
      <p>The caller can now make another
      call to the recv function and now expect data.</p>
      <p>Note that all other users are <em>locked out</em> until the
      'current user' has called the function (recv in this case).</p>
      <p>Another message the user must be prepared for (when making asynchronous
      calls) is the <c>abort</c> message:</p>
      <taglist>
	<!-- NOTE THAT THE EMPTY TAG IS INTENTIONAL -->
	<tag></tag>
	<item><c>{'$socket', socket(), abort, Info}</c></item>
      </taglist>
      <p>This message indicates
      that the (asynchronous) operation has been aborted.
      If, for instance, the socket has been closed (by another process),
      <c>Info</c> will be <c>{SelectHandle, closed}</c>. </p>
    </note>
    <note>
      <p>There is currently <em>no</em> support for Windows. </p>
      <p>Support for IPv6 has been implemented but <em>not</em> tested. </p>
      <p>SCTP has only been partly implemented (and not tested). </p>
    </note>
  </description>

  <datatypes>
    <datatype>
      <name name="domain"/>
    </datatype>
    <datatype>
      <name name="type"/>
    </datatype>
    <datatype>
      <name name="protocol"/>
      <desc>
	<p>
	  An <c>atom()</c> means any protocol as enumerated by the
	  <c>C</c> library call <c>getprotoent()</c>
	  on the platform, or at least the supported ones of
	  <c>ip | ipv6 | tcp | udp | sctp</c>.
	</p>
	<p>
	  An <c>integer()</c> means a native protocol number
	  on the platform.  The default protocol is <c>0</c>.
	</p>
	<p>
	  The call
	  <seemfa marker="#supports/2"><c>supports(protocols)</c></seemfa>
	  returns the supported protocol atoms.
	</p>
      </desc>
    </datatype>
    <datatype>
      <name>socket()</name>
      <desc><p>As returned by
        <seemfa marker="#open/1"><c>open/1,2,3,4</c></seemfa> and
        <seemfa marker="#accept/1"><c>accept/1,2</c></seemfa>.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="select_tag"/>
      <desc>
	<p>A tag that describes the (select) operation.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="select_handle"/>
      <desc>
	<p>A term that uniquely identifies the (select) operation.</p>
      </desc>
    </datatype>
    <datatype>
      <name name="select_info"/>
    </datatype>
    <datatype>
      <name name="socket_counters"/>
    </datatype>
    <datatype>
      <name name="socket_info"/>
    </datatype>
    <datatype>
      <name name="in_addr"/>
    </datatype>
    <datatype>
      <name name="in6_addr"/>
    </datatype>
    <datatype>
      <name name="sockaddr"/>
    </datatype>
    <datatype>
      <name name="sockaddr_in"/>
    </datatype>
    <datatype>
      <name name="sockaddr_in6"/>
    </datatype>
    <datatype>
      <name name="sockaddr_un"/>
    </datatype>
    <datatype>
      <name name="sockaddr_ll"/>
    </datatype>
    <datatype>
      <name name="packet_type"/>
    </datatype>
    <datatype>
      <name name="port_number"/>
    </datatype>
    <datatype>
      <name name="in6_flow_info"/>
    </datatype>
    <datatype>
      <name name="in6_scope_id"/>
    </datatype>
    <datatype>
      <name name="send_flag"/>
    </datatype>
    <datatype>
      <name name="recv_flag"/>
    </datatype>
    <datatype>
      <name name="sockopt_level"/>
      <desc>
	<p>
	  The OS protocol levels for socket options
	  with the following names in OS header files:
	</p>
	<taglist>
	  <tag><c>socket</c></tag>
	  <item>
	    <c>SOL_SOCKET</c> with options named <c>SO_</c>*.
	  </item>
	  <tag><c>ip</c></tag>
	  <item>
	    <c>IPPROTO_IP</c> a.k.a <c>SOL_IP</c>
	     with options named <c>IP_</c>*.
	  </item>
	  <tag><c>ipv6</c></tag>
	  <item>
	    <c>IPPROTO_IPV6</c> a.k.a <c>SOL_IPV6</c>
	    with options named <c>IPV6_</c>*.
	  </item>
	  <tag><c>tcp</c></tag>
	  <item>
	    <c>IPPROTO_TCP</c> with options named <c>TCP_</c>*.
	  </item>
	  <tag><c>udp</c></tag>
	  <item>
	    <c>IPPROTO_UDP</c> with options named <c>UDP_</c>*.
	  </item>
	  <tag><c>sctp</c></tag>
	  <item>
	    <c>IPPROTO_SCTP</c> with options named <c>SCTP_</c>*.
	  </item>
	</taglist>
      </desc>
    </datatype>
    <datatype>
      <name name="otp_socket_option"/>
      <desc>
	<p>
	  These are socket options for the <c>otp</c> protocol level,
	  which is above all OS protocol levels.
	  They affect Erlang/OTP's socket implementation.
	</p>
	<taglist>
	  <tag><c>debug</c></tag>
	  <item><c>boolean()</c> - Activate debug printout.</item>
	  <tag><c>iow</c></tag>
	  <item>
	    <c>boolean()</c>
	    - Inform On Wrap of statistics counters.
	  </item>
	  <tag><c>controlling_process</c></tag>
	  <item>
	    <c>pid()</c>
	    - The socket "owner".
	    Only the current controlling process can set this option.
	  </item>
	  <tag><c>rcvbuf</c></tag>
	  <item>
	    <c>
	      BufSize&nbsp;::&nbsp;(default&nbsp;|&nbsp;integer()>0) |
	      {N&nbsp;::&nbsp;integer()>0,
	      BufSize&nbsp;::&nbsp;(default&nbsp;|&nbsp;integer()>0)}
	    </c>
	    - Receive buffer size.
	    <c>default</c> is only valid for
	    <seemfa marker="#setopt/3"><c>setopt/3</c></seemfa>
	    and will not be returned from
	    <seemfa marker="#getopt/2"><c>getopt/2</c></seemfa>.
	    <c>N</c> specifies the number of read attempts to do
	    in a tight loop before assuming no more data is pending.
	  </item>
	  <tag><c>rcvctrlbuf</c></tag>
	  <item>
	    <c>
	      BufSize&nbsp;::&nbsp;(default&nbsp;|&nbsp;integer()>0)
	    </c>
	    - Buffer size for received ancillary messages.
	  </item>
	  <tag><c>sndctrlbuf</c></tag>
	  <item>
	    <c>
	      BufSize&nbsp;::&nbsp;(default&nbsp;|&nbsp;integer()>0)
	    </c>
	    - Buffer size for sent ancillary messages.
	  </item>
	  <tag><c>fd</c></tag>
	  <item>
	    <c>integer()</c>
	    - The OS protocol levels' socket descriptor.
	    Only valid for
	    <seemfa marker="#getopt/2"><c>getopt/2</c></seemfa>.
	    Functions <seemfa marker="#open/1"><c>open/1,2</c></seemfa>
	    can be used to create a socket according to this module
	    from an existing OS socket descriptor.
	  </item>
	</taglist>
	<p>
	  Options not described here are intentionally undocumented
	  and for Erlang/OTP internal use only.
	</p>
      </desc>
    </datatype>
    <datatype>
      <name name="socket_option"/>
      <desc>
	<p>
	  Socket option on the form
	  <c>{Level, Opt}</c> where the OS protocol
	  <c>Level</c> =
	  <seetype marker="#sockopt_level"><c>sockopt_level()</c></seetype>
	  and <c>Opt</c> is a socket option on that protocol level.
	</p>
	<p>
	  The OS name for an options is, except where otherwise noted,
	  the <c>Opt</c> atom, in capitals, with prefix according to
	  <seetype marker="#sockopt_level"><c>sockopt_level()</c></seetype>.
	</p>
	<note><p>See the OS documentation for every socket option.</p></note>
	<p>
	  The value type for an option is <c>boolean()</c>
	  if the OS documentation indicates so
	  (that it is an on/off option).
	  Other options are <c>integer()</c> maybe in
	  a restricted range (for example byte: <c>0..255</c>),
	  unless noted below.
	</p>
	<p>
	  Options with special value types or other pecularities
	  for protocol
	  <seetype marker="#sockopt_level">level <c>socket</c></seetype>.
	</p>
	<taglist>
	  <tag><c>{socket, bindtodevice}</c></tag>
	  <item>
	    <p><c>Value = string()</c></p>
	  </item>
	  <tag><c>{socket, domain}</c></tag>
	  <item>
	    <p>
	      <c>Value =</c>
	      <seetype marker="#domain"><c>domain()</c></seetype>
	      <c>| integer()</c>
	    </p>
	    <p>
	      The socket's protocol domain.  Valid to get, not to set.
	      Does <em>not</em> work on for instance FreeBSD.
	    </p>
	  </item>
	  <tag><c>{socket, linger}</c></tag>
	  <item>
	    <p>
	      <c>
		Value = abort |
		{OnOff&nbsp;::&nbsp;boolean(),&nbsp;Linger&nbsp;::&nbsp;integer()}
	      </c>
	    </p>
	    <p>
	      The value <c>abort</c>
	      is shorthand for <c>{true, 0}</c>,
	      is only valid to set,
	      and will not returned from a get.
	    </p>
	  </item>
	  <tag><c>{socket, peek_off}</c></tag>
	  <item>
	    <p>
	      Currently disabled due to a possible infinite loop when calling
	      <seemfa marker="#recv/1"><c>recv/1-4</c></seemfa>
	      with
	      <seetype marker="#recv_flag"><c>peek</c></seetype>
	      in <c>Flags</c>.
	    </p>
	  </item>
	  <tag><c>{socket, protocol}</c></tag>
	  <item>
	    <p>
	      <c>Value =</c>
	      <seetype marker="#protocol"><c>protocol()</c></seetype>
	      <c>| integer()</c>
	    </p>
	    <p>
	      The socket's protocol.  Valid to get, not to set.
	      Does <em>not</em> work on for instance Darwin.
	    </p>
	  </item>
	  <tag><c>{socket, rcvtimeo}</c></tag>
	  <item>
	    <p><c>Value = #{sec := integer(), usec := integer()}</c></p>
	    <p>
	      This option is not normally supported;
	      OTP has to be explicitly built with the
	      <c>--enable-esock-rcvsndtimeo</c> configure option
	      for this to be available.
	    </p>
	    <p>
	      Since our implementation uses nonblocking sockets,
	      it is unknown if and how this option works,
	      or even if it may cause malfunction.
	      Therefore, we do not recommend setting this option.
	    </p>
	    <p>
	      Instead, use the <c>Timeout</c> argument to,
	      for instance, the
	      <seemfa marker="#recv/3"><c>recv/3</c></seemfa>
	      function.
	    </p>
	  </item>
	  <tag><c>{socket, sndtimeo}</c></tag>
	  <item>
	    <p><c>Value = #{sec := integer(), usec := integer()}</c></p>
	    <p>
	      This option is not normally supported;
	      OTP has to be explicitly built with the
	      <c>--enable-esock-rcvsndtimeo</c> configure option
	      for this to be available.
	    </p>
	    <p>
	      Since our implementation uses nonblocking sockets,
	      it is unknown if and how this option works,
	      or even if it may cause malfunction.
	      Therefore, we do not recommend setting this option.
	    </p>
	    <p>
	      Instead, use the <c>Timeout</c> argument to,
	      for instance, the
	      <seemfa marker="#send/3"><c>send/3</c></seemfa>
	      function. 
	    </p>
	  </item>
	  <tag><c>{socket, type}</c></tag>
	  <item>
	    <p>
	      <c>Value =</c>
	      <seetype marker="#type"><c>type()</c></seetype>
	      <c>| integer()</c>
	    </p>
	    <p>
	      The socket's type.  Valid to get, not to set.
	    </p>
	  </item>
	</taglist>
      </desc>
    </datatype>
    <datatype>
      <name name="timeval"/>
    </datatype>
    <datatype>
      <name name="ip_tos"/>
    </datatype>
    <datatype>
      <name name="ip_pktinfo"/>
    </datatype>
    <datatype>
      <name name="ipv6_pktinfo"/>
    </datatype>
    <datatype>
      <name name="msghdr_flag"/>
    </datatype>
    <datatype>
      <name name="msghdr"/>
    </datatype>
    <datatype>
      <name name="cmsghdr_level"/>
    </datatype>
    <datatype>
      <name name="cmsghdr_type"/>
    </datatype>
    <datatype>
      <name name="cmsghdr_recv"/>
    </datatype>
    <datatype>
      <name name="cmsghdr_send"/>
    </datatype>
    <datatype>
      <name name="icmp_dest_unreach"/>
    </datatype>
    <datatype>
      <name name="icmpv6_dest_unreach"/>
    </datatype>
    <datatype>
      <name name="ee_origin"/>
    </datatype>
    <datatype>
      <name name="extended_err"/>
    </datatype>
    <datatype>
      <name name="posix"/>
      <desc>
	<p>
	  The POSIX error codes originates from the
	  OS level socket interface.
	</p>
      </desc>
    </datatype>
  </datatypes>

  <funcs>
    <func>
      <name name="accept" arity="1" since="OTP 22.0"/>
      <name name="accept" arity="2" clause_i="2" since="OTP 22.0"/>
      <fsummary>Accept a connection on a socket.</fsummary>
      <desc>
        <p>Accept a connection on a socket.</p>
        <p>This call is used with connection-based socket types
	(<c>stream</c> or <c>seqpacket</c>). It extracs the first pending
	connection request for the listen socket and returns the (newly)
	connected socket.</p>
      </desc>
    </func>

    <func>
      <name name="accept" arity="2" clause_i="1" anchor="accept_async" since="OTP 22.1"/>
      <fsummary>Accept a connection on a socket.</fsummary>
      <desc>
        <p>Accept a connection on a socket.</p>

	<p>This call is used with connection-based socket types
	(<c>stream</c> or <c>seqpacket</c>). It extracs the first pending
	connection request for the listen socket and returns the (newly)
	connected socket.</p>

	<p>
	  In the case when there is no connections waiting,
	  the function will return
	  <seetype marker="#select_info"><c>{select, <anno>SelectInfo</anno>}</c></seetype>.
	  The caller will then receive a select message,
	  <c>{'$socket', Socket, select, SelectHandle}</c> (
	  with
	  <seetype marker="socket#select_handle"><c>SelectHandle</c></seetype>
	  from
	  <seetype marker="#select_info">
	    <c><anno>SelectInfo</anno></c>
	  </seetype>
	  ) when a client connects.
	  A subsequent call to <c>accept/1,2</c>
	  will then return the socket.
	</p>
      </desc>
    </func>

    <func>
      <name name="bind" arity="2" since="OTP 22.0"/>
      <fsummary>Bind a name to a socket.</fsummary>
      <desc>
        <p>Bind a name to a socket.</p>
        <p>When a socket is created
	(with <seemfa marker="#open/2"><c>open</c></seemfa>),
	it has no address assigned to it. <c>bind</c> assigns the
	address specified by the <c>Addr</c> argument.</p>
	<p>The rules used for name binding vary between domains.</p>
      </desc>
    </func>

    <func>
      <name name="cancel" arity="2" since="OTP 22.1"/>
      <fsummary>Cancel an asynchronous request.</fsummary>
      <desc>
	<p>Cancel an asynchronous request.</p>

	<p>Call this function in order to cancel a previous
	asynchronous call to, e.g.
	<seemfa marker="#recv/3"><c>recv/3</c></seemfa>. </p>
      </desc>
    </func>

    <func>
      <name name="close" arity="1" since="OTP 22.0"/>
      <fsummary>Close a socket.</fsummary>
      <desc>
	<p>Closes the socket.</p>

	<note>
	  <p>Note that for e.g. <c>protocol</c> = <c>tcp</c>, most implementations
	  doing a close does not guarantee that any data sent is delivered to
	  the recipient before the close is detected at the remote side. </p>
	  <p>One way to handle this is to use the
	  <seemfa marker="#shutdown/2"><c>shutdown</c></seemfa>
	  function
	  (<c>socket:shutdown(Socket, write)</c>) to signal that no more data is
	  to be sent and then wait for the read side of the socket to be closed.</p>
	</note>
      </desc>
    </func>

    <func>
      <name name="connect" arity="2" since="OTP 22.0"/>
      <name name="connect" arity="3" clause_i="2" since="OTP 22.0"/>
      <fsummary>Initiate a connection on a socket.</fsummary>
      <desc>
        <p>This function connects the socket to the address
	specied by the <c>SockAddr</c> argument.</p>
      </desc>
    </func>

    <func>
      <name name="connect" arity="3" clause_i="1" anchor="connect_async" since="OTP 22.1"/>
      <fsummary>Initiate a connection on a socket.</fsummary>
      <desc>
        <p>
	  This function connects the socket to the address
	  specified by the <c><anno>SockAddr</anno></c> argument.
	</p>

 	<p>
	  In the case when its not possible to immediately establish a
	  connection, the function will return
	  <seetype marker="#select_info"><c>{select, <anno>SelectInfo</anno>}</c></seetype>.
	  The caller will then receive a select message,
	  <c>{'$socket', Socket, select, SelectHandle}</c> (
	  with
	  <seetype marker="socket#select_handle"><c>SelectHandle</c></seetype>
	  from
	  <seetype marker="#select_info">
	    <c><anno>SelectInfo</anno></c>
	  </seetype>
	  ) when the connection is completed. 
	  A subsequent call to <c>connect/2,3</c>
	  will then finalize the connection.
	</p>
     </desc>
    </func>

    <func>
      <name name="getopt" arity="2" clause_i="1" since="OTP 22.0"/>
      <fsummary>
	Get a socket option from the protocol level <c>otp</c>.
      </fsummary>
      <desc>
        <p>
	  Gets a socket option from the protocol level <c>otp</c>,
	  which is this implementation's level
	  above the OS protocol layers.
	</p>
	<p>
	  See the type
	  <seetype marker="#otp_socket_option">
	    otp_socket_option()
	  </seetype>
	  for a description of the options on this level.
	</p>
      </desc>
    </func>

    <func>
      <name name="getopt" arity="2" clause_i="2" since="OTP 22.0"/>
      <fsummary>
	Get a socket option from one of the OS's protocol levels.
      </fsummary>
      <desc>
        <p>
	  Gets a socket option from one of the OS's protocol levels.
	  See the type
	  <seetype marker="#socket_option">socket_option()</seetype>
	  for which options that this implementation knows about,
	  how they are related to option names in the OS,
	  and if there are known pecularities with any of them.
	</p>
	<p>
	  What options are valid depends on what kind of socket it is
	  (<seetype marker="#domain"><c>domain()</c></seetype>,
	  <seetype marker="#type"><c>type()</c></seetype> and
	  <seetype marker="#protocol"><c>protocol()</c></seetype>).
	</p>
	<p>
	  See the
	  <seeguide marker="socket_usage#socket_options">
	    socket options
	  </seeguide>
	  chapter of the users guide for more info.
	</p>
	<note>
	  <p>
	    Not all options are valid, or possible to get,
	    on all platforms.
	    That is, even if "we" support an option;
	    it does not mean that the underlying OS does.
	  </p>
	</note>
      </desc>
    </func>

    <func>
      <!--
	  Backwards compatibility function - remove documentation?
	  Document the Native clause?
      -->
      <name since="OTP 22.0">
	getopt(Socket, Level, Opt) -> ok | {error, Reason}
      </name>
      <fsummary>
	Get a socket protocol option.
      </fsummary>
      <type>
	<v>
	  Socket = <seetype marker="#socket">socket()</seetype>
	</v>
	<v>
	  Reason = <seetype marker="inet#posix">inet:posix()</seetype>
	  | invalid | closed
	</v>
      </type>
      <desc>
	<p>Backwards compatibility function.</p>
        <p>
	  The same as
	  <seemfa marker="#getopt/2">
	    <c>getopt(Socket, {Level, Opt})</c>
	  </seemfa>
	</p>
      </desc>
    </func>

    <func>
      <name name="getopt_native" arity="3" clause_i="1" since="OTP 22.0"/>
      <name name="getopt_native" arity="3" clause_i="2" since="OTP 22.0"/>
      <name name="getopt_native" arity="3" clause_i="3" since="OTP 22.0"/>
      <fsummary>Get a "native" socket option.</fsummary>
      <desc>
        <p>
	  Gets a socket option that may be unknown to our
	  implementation, or that has a type not compatible
	  with our implementation, that is; in "native mode".
	</p>
	<p>
	  The socket option may be specified with an ordinary
	  <seetype marker="#socket_option">
	    <c>socket_option()</c>
	  </seetype>
	  tuple, with a known 
	  <seetype marker="#sockopt_level">
	    <c><anno>Level</anno> = sockopt_level()</c>
	  </seetype>
	  and an integer <c><anno>NativeOpt</anno></c>,
	  or with both an integer <c><anno>NativeLevel</anno></c>
	  and <c><anno>NativeOpt</anno></c>.
	</p>
	<p>
	  How to decode the option value has to be specified
	  either with <c><anno>ValueType</anno></c>,
	  or by specifying the <c><anno>ValueSize</anno></c>
	  for a <c>binary()</c> that will contain
	  the fetched option value.
	</p>
	<p>
	  If <c><anno>ValueType</anno></c> is <c>integer</c>
	  a <c>C</c> type <c>(int)</c> will be fetched,
	  if it is <c>boolean</c> a <c>C</c> type <c>(int)</c>
	  will be fetched and converted into a <c>boolean()</c>
	  according to the <c>C</c> implementation.
	</p>
	<p>
	  What options are valid depends on what kind of socket it is
	  (<seetype marker="#domain"><c>domain()</c></seetype>,
	  <seetype marker="#type"><c>type()</c></seetype> and
	  <seetype marker="#protocol"><c>protocol()</c></seetype>).
	</p>
	<p>
	  The integer values for 
	  <c><anno>NativeLevel</anno></c> and
	  <c><anno>NativeOpt</anno></c>
	  as well as the <c><anno>Value</anno></c> encoding
	  has to be deduced from the header files for
	  the running system.
	</p>
      </desc>
    </func>

    <func>
      <name name="info" arity="1" since="OTP 22.1"/>
      <fsummary>Get miscellaneous socket info.</fsummary>
      <desc>
        <p>Get miscellaneous info about the socket.</p>
	<p>The function returns a map with each info item as a key-value
	binding. It reflects the "current" state of the socket. </p>
	<note>
	  <p>In order to ensure data integrity, mutex'es are taken when
	  needed. So, do not call this function often. </p>
	</note>
      </desc>
    </func>

    <func>
      <name name="is_supported" arity="1" since="OTP 23.0"/>
      <name name="is_supported" arity="2" since="OTP 23.0"/>
      <name name="is_supported" arity="3" since="OTP 23.0"/>
      <fsummary>Report info about what the platform supports.</fsummary>
      <desc>
	<p>
	  This function retreives information about what the
	  platform supports,  such as if SCTP is supported,
	  or if a socket options are supported.
	</p>
	<p>
	  For keys other than the known <c>false</c> is returned.
	  Note that in a future version or on a different platform
	  there might be more supported items.
	</p>
	<p>
	  This functions returns a <c>boolean</c> corresponding to what
	  <seemfa marker="#supports/0"><c>supports/0-2</c></seemfa>
	  reports for the same <c><anno>Key1</anno></c>
	  (and <c><anno>Key2</anno></c>
	  (and <c><anno>Key3</anno> = Opt</c>: socket option)).
	</p>
      </desc>
    </func>

    <func>
      <name name="listen" arity="1" since="OTP 22.0"/>
      <name name="listen" arity="2" since="OTP 22.0"/>
      <fsummary>Listen for connections on a socket.</fsummary>
      <desc>
        <p>Listen for connections on a socket.</p>
      </desc>
    </func>

    <func>
      <name name="number_of" arity="0" since="OTP 22.3"/>
      <fsummary>Get the number of active sockets.</fsummary>
      <desc>
        <p>Returns the number of active sockets.</p>
      </desc>
    </func>

    <func>
      <name name="open" arity="1" since="OTP 23.0"/>
      <name name="open" arity="2" clause_i="1" since="OTP 23.0"/>
      <fsummary>Create an endpoint for communication.</fsummary>
      <desc>
	<p>Create an endpoint (socket) for communication based on an
	already existing file descriptor.
	The function attempts to retrieve domain, type and protocol from
	the system. This is however not possible on all platforms, and
	in those cases it expects it in <c>Opts</c>. </p>

	<p>The <c>Opts</c> argument is intended for providing extra
	information for the open call:</p>
	<taglist>
	  <tag>
	    <c>domain => </c><seetype marker="#domain"><c>domain()</c></seetype>
	  </tag>
	  <item>
	    <p>Which domain is the descriptor of. </p>
	  </item>

	  <tag>
	    <c>type => </c><seetype marker="#type"><c>type()</c></seetype>
	  </tag>
	  <item>
	    <p>Which type is the descriptor of. </p>
	  </item>

	  <tag>
	    <c>protocol => </c><seetype marker="#protocol"><c>protocol()</c></seetype>
	  </tag>
	  <item>
	    <p>Which protocol is the descriptor of. </p>
	  </item>

	  <tag><c>dup => boolean()</c></tag>
	  <item>
	    <p>Shall the provided descriptor be duplicated (dup) or not.
	    <br/>Defaults to <c>true</c>. </p>
	  </item>

	  <tag><c>debug => boolean()</c></tag>
	  <item>
	    <p>Enable or disable debug during the open call.
	    <br/>Defaults to <c>false</c>. </p>
	  </item>

	  <tag><c><![CDATA[use_registry: boolean()]]></c></tag>
	  <item>
	    <p>Enable or disable use of the socket registry for this socket.
	    This overrides the global value.
	    <br/>Defaults to the global value, see
	    <seemfa marker="#use_registry/1"><c>use_registry/1</c></seemfa>.
	    </p>
	  </item>

	</taglist>

	<note>
	  <p>This function should be used with care! </p>
	  <p>On some platforms its <em>necessary</em> to provide the
	  <c>protocol</c> as its impossible to retrieve it. </p>
	</note>
      </desc>
    </func>

    <func>
      <name name="open" arity="2" clause_i="2" since="OTP 22.0"/>
      <name name="open" arity="3" clause_i="1" since="OTP 23.1"/>
      <name name="open" arity="3" clause_i="2" since="OTP 22.0"/>
      <name name="open" arity="4" since="OTP 22.0"/>
      <fsummary>Create an endpoint for communication.</fsummary>
      <desc>
	<p>Creates an endpoint (socket) for communication.</p>

	<p>For some <c>types</c> there is a default protocol,
	indicated by <c>default</c>, which it <em>may</em> be
	possible to specify.
	And for <c>Domain = local</c>,
	if a protocol <em>is</em> specified,
	it <em>must</em> be <c>default</c>. </p>

	<p>The <c>Opts</c> argument is intended for "other" options.
	The supported option(s) are described below:</p>

	<taglist>
	  <tag><c><![CDATA[netns: string()]]></c></tag>
	  <item>
	    <p>Used to set the network namespace during the open call.
	    Only supported on the Linux platform. </p>
	  </item>

	  <tag><c><![CDATA[debug: boolean()]]></c></tag>
	  <item>
	    <p>Enable or disable debug during the open call.
	    <br/>Defaults to <c>false</c>. </p>
	  </item>

	  <tag><c><![CDATA[use_registry: boolean()]]></c></tag>
	  <item>
	    <p>Enable or disable use of the socket registry for this socket.
	    This overrides the global value.
	    <br/>Defaults to the global value, see
	    <seemfa marker="#use_registry/1"><c>use_registry/1</c></seemfa>.
	    </p>
	  </item>

	</taglist>

	<note>
	  <p>It may not be possible to specify the default protocol (except
	  when <c>Domain = local</c>). We need to be able to retreive
	  the resulting protocol, which is <em>not</em> possble on all
	  platforms. </p>
	</note>
      </desc>
    </func>

    <func>
      <name name="peername" arity="1" since="OTP 22.0"/>
      <fsummary>Get name of connected socket peer.</fsummary>
      <desc>
        <p>Returns the address of the peer connected to the socket.</p>
      </desc>
    </func>

    <func>
      <name name="recv" arity="1" since="OTP 22.0"/>
      <name name="recv" arity="2" since="OTP 22.0"/>
      <name name="recv" arity="3" clause_i="1" since="OTP 22.0"/>
      <name name="recv" arity="3" clause_i="3" since="OTP 22.0"/>
      <name name="recv" arity="4" clause_i="2" since="OTP 22.0"/>
      <fsummary>Receive a message from a socket.</fsummary>
      <desc>
        <p>Receive a message from a socket.</p>
	<p>There is a special case for the argument <c>Length</c>.
	If it is set to zero (0), it means "give me everything you 
	currently have".</p>
      </desc>
    </func>

    <func>
      <name name="recv" arity="3" clause_i="2" anchor="recv_async" since="OTP 22.1"/>
      <name name="recv" arity="4" clause_i="1" since="OTP 22.1"/>
      <fsummary>Receive a message from a socket.</fsummary>
      <desc>
        <p>Receive a message from a socket.</p>

	<p>There is a special case for the argument <c>Length</c>.
	If it is set to zero (0), it means "give me everything you 
	currently have".</p>

	<p>
	  In the case when there is no data waiting,
	  the function will return
	  <seetype marker="#select_info"><c>{select, <anno>SelectInfo</anno>}</c></seetype>.
	  The caller will then receive a select message,
	  <c>{'$socket', Socket, select, SelectHandle}</c> (
	  with
	  <seetype marker="socket#select_handle"><c>SelectHandle</c></seetype>
	  from
	  <seetype marker="#select_info">
	    <c><anno>SelectInfo</anno></c>
	  </seetype>
	  ) when data has arrived.
	  A subsequent call to <c>accept/1,2</c>
	  will then return the data.
	</p>
	<p>
	  Note that if a length (<c>> 0</c>) is specified,
	  and only part of that amount of data is available,
	  the function will return
	  <seetype marker="#select_info">
	    <c>{ok, {<anno>Data</anno>, <anno>SelectInfo</anno></c>
	  </seetype>
	  with partial data.  If the caller doesn't want to wait
	  for the remaining data, it must call
	  <seemfa marker="#cancel/2"><c>cancel/2</c></seemfa>.
	</p>
      </desc>
    </func>

    <func>
      <name name="recvfrom" arity="1" since="OTP 22.0"/>
      <name name="recvfrom" arity="2" since="OTP 22.0"/>
      <name name="recvfrom" arity="3" clause_i="2" since="OTP 22.0"/>
      <name name="recvfrom" arity="3" clause_i="3" since="OTP 22.0"/>
      <name name="recvfrom" arity="3" clause_i="5" since="OTP 22.0"/>
      <name name="recvfrom" arity="4" clause_i="2" since="OTP 22.0"/>
      <fsummary>Receive a message from a socket.</fsummary>
      <desc>
        <p>Receive a message from a socket.</p>
        <p>This function reads "messages", which means that regardless of
	how much we want to read, it returns when we get a message
	(if the buffer size is too small, the message will be truncated).</p>
        <p>The <c>BufSz</c> argument basically defines the size of the
	receive buffer. By setting the value to zero (0), the configured
	size (setopt with <c>Level</c> = <c>otp</c> and
	<c>Key</c> = <c>rcvbuf</c>) is used.</p>
        <p>It may be impossible to know what (buffer) size is appropriate
	"in advance", and in those cases it may be convenient to use the
	(recv) 'peek' flag. When this flag is provided, the message is *not*
	"consumed" from the underlying buffers, so another recvfrom call
	is needed, possibly with a then adjusted buffer size.</p>
      </desc>
    </func>

    <func>
      <name name="recvfrom" arity="3" clause_i="1" anchor="recvfrom_async" since="OTP 22.1"/>
      <name name="recvfrom" arity="3" clause_i="4" since="OTP 22.1"/>
      <name name="recvfrom" arity="4" clause_i="1" since="OTP 22.1"/>
      <fsummary>Receive a message from a socket.</fsummary>
      <desc>
        <p>Receive a message from a socket.</p>
        <p>This function reads "messages", which means that regardless of
	how much we want to read, it returns when we get a message
	(if the buffer size is too small, the message will be truncated).</p>
        <p>The <c>BufSz</c> argument basically defines the size of the
	receive buffer. By setting the value to zero (0), the configured
	size (setopt with <c>Level</c> = <c>otp</c> and
	<c>Key</c> = <c>rcvbuf</c>) is used.</p>
        <p>It may be impossible to know what (buffer) size is appropriate
	"in advance", and in those cases it may be convenient to use the
	(recv) 'peek' flag. When this flag is provided, the message is *not*
	"consumed" from the underlying buffers, so another recvfrom call
	is needed, possibly with a then adjusted buffer size.</p>

	<p>
	  In the case when there is no data waiting,
	  the function will return
	  <seetype marker="#select_info"><c>{select, <anno>SelectInfo</anno>}</c></seetype>.
	  The caller will then receive a select message,
	  <c>{'$socket', Socket, select, SelectHandle}</c> (
	  with
	  <seetype marker="socket#select_handle"><c>SelectHandle</c></seetype>
	  from
	  <seetype marker="#select_info">
	    <c><anno>SelectInfo</anno></c>
	  </seetype>
	  ) when data has arrived.
	  A subsequent call to <c>recvfrom/1-4</c> will then return the data.
	</p>
      </desc>
    </func>

    <func>
      <name name="recvmsg" arity="1" since="OTP 22.0"/>
      <name name="recvmsg" arity="2" clause_i="1" since="OTP 22.0"/>
      <name name="recvmsg" arity="2" clause_i="3" since="OTP 22.0"/>
      <name name="recvmsg" arity="3" clause_i="2" since="OTP 22.0"/>
      <name name="recvmsg" arity="3" clause_i="3" since="OTP 22.0"/>
      <name name="recvmsg" arity="5" clause_i="2" since="OTP 22.0"/>
      <fsummary>Receive a message from a socket.</fsummary>
      <desc>
        <p>Receive a message from a socket.</p>
        <p>This function reads "messages", which means that regardless of
	how much we want to read, it returns when we get a message.</p>
	<p>The message will be delivered in the form of a <c>msghdr()</c>,
	which may contain the source address (if socket not connected),
	a list of <c>cmsghdr_recv()</c> (depends on what socket options have
	been set and what the protocol and platform supports) and
	also a set of flags, providing further info about the read. </p>
	
        <p>The <c>BufSz</c> argument basically defines the size of the
	receive buffer. By setting the value to zero (0), the configured
	size (setopt with <c>Level</c> = <c>otp</c> and
	<c>Key</c> = <c>rcvbuf</c>) is used.</p>

        <p>The <c>CtrlSz</c> argument basically defines the size of the
	receive buffer for the control messages.
	By setting the value to zero (0), the configured size (setopt
	with <c>Level</c> = <c>otp</c>) is used.</p>

	<p>It may be impossible to know what (buffer) size is appropriate
	"in advance", and in those cases it may be convenient to use the
	(recv) 'peek' flag. When this flag is provided, the message is *not*
	"consumed" from the underlying buffers, so another recvmsg call
	is needed, possibly with a then adjusted buffer size.</p>
      </desc>
    </func>

    <func>
      <name name="recvmsg" arity="2" clause_i="2" anchor="recvmsg_async" since="OTP 22.1"/>
      <name name="recvmsg" arity="3" clause_i="1" since="OTP 22.1"/>
      <name name="recvmsg" arity="5" clause_i="1" since="OTP 22.1"/>
      <fsummary>Receive a message from a socket.</fsummary>
      <desc>
        <p>Receive a message from a socket.</p>
        <p>This function reads "messages", which means that regardless of
	how much we want to read, it returns when we get a message.</p>
	<p>The message will be delivered in the form of a <c>msghdr()</c>,
	which may contain the source address (if socket not connected),
	a list of <c>cmsghdr_recv()</c> (depends on what socket options have
	been set and what the protocol and platform supports) and
	also a set of flags, providing further info about the read. </p>
	
        <p>The <c>BufSz</c> argument basically defines the size of the
	receive buffer. By setting the value to zero (0), the configured
	size (setopt with <c>Level</c> = <c>otp</c> and
	<c>Key</c> = <c>rcvbuf</c>) is used.</p>

        <p>The <c>CtrlSz</c> argument basically defines the size of the
	receive buffer for the control messages.
	By setting the value to zero (0), the configured size (setopt
	with <c>Level</c> = <c>otp</c>) is used.</p>

	<p>It may be impossible to know what (buffer) size is appropriate
	"in advance", and in those cases it may be convenient to use the
	(recv) 'peek' flag. When this flag is provided, the message is *not*
	"consumed" from the underlying buffers, so another recvmsg call
	is needed, possibly with a then adjusted buffer size.</p>

	<p>
	  In the case when there is no data waiting,
	  the function will return
	  <seetype marker="#select_info"><c>{select, <anno>SelectInfo</anno>}</c></seetype>.
	  The caller will then receive a select message,
	  <c>{'$socket', Socket, select, SelectHandle}</c> (
	  with
	  <seetype marker="socket#select_handle"><c>SelectHandle</c></seetype>
	  from
	  <seetype marker="#select_info">
	    <c><anno>SelectInfo</anno></c>
	  </seetype>
	  ) when data has arrived.
	  A subsequent call to <c>recvmsg/1-3,5</c> will then return the data.
	</p>
      </desc>
    </func>

    <func>
      <name name="send" arity="2" since="OTP 22.0"/>
      <name name="send" arity="3" clause_i="1" since="OTP 22.0"/>
      <name name="send" arity="3" clause_i="3" since="OTP 22.0"/>
      <name name="send" arity="4" clause_i="2" since="OTP 22.0"/>
      <fsummary>Send a message on a socket.</fsummary>
      <desc>
        <p>Send a message on a connected socket.</p>
      </desc>
    </func>

    <func>
      <name name="send" arity="3" clause_i="2" anchor="send_async" since="OTP 22.1"/>
      <name name="send" arity="4" clause_i="1" since="OTP 22.1"/>
      <fsummary>Send a message on a socket.</fsummary>
      <desc>
        <p>Send a message on a connected socket.</p>
	<p>
	  In the case when there is no room in the (system-) buffers,
	  the function will return
	  <seetype marker="#select_info"><c>{select, <anno>SelectInfo</anno>}</c></seetype>.
	  The caller will then receive a select message,
	  <c>{'$socket', Socket, select, SelectHandle}</c> (
	  with
	  <seetype marker="socket#select_handle"><c>SelectHandle</c></seetype>
	  from
	  <seetype marker="#select_info">
	    <c><anno>SelectInfo</anno></c>
	  </seetype>
	  ) when there is room for more data
	  A subsequent call to <c>send/2-4</c> will then send the data.
	</p>
	<p>
	  Note that if not all the data was sent, the function will return
	  <seetype marker="#select_info">
	    <c>{ok, {<anno>RestData</anno>, <anno>SelectInfo</anno>}</c>
	  </seetype>
	  If the caller does not want to wait to be able to send the rest,
	  it should call
	  <seemfa marker="#cancel/2"><c>cancel/2</c></seemfa>.
	</p>
      </desc>
    </func>

    <func>
      <name name="sendmsg" arity="2" since="OTP 22.0"/>
      <name name="sendmsg" arity="3" clause_i="1" since="OTP 22.0"/>
      <name name="sendmsg" arity="3" clause_i="3" since="OTP 22.0"/>
      <name name="sendmsg" arity="4" clause_i="2" since="OTP 22.0"/>
      <fsummary>Send a message on a socket.</fsummary>
      <desc>
	<p>Send a message on a socket. The destination, if needed
	(socket <em>not</em> connected) is provided in the <c>MsgHdr</c>,
	which also contains the message to send,
	The <c>MsgHdr</c> may also contain an list of optional <c>cmsghdr_send()</c>
	(depends on what the protocol and platform supports).</p>

	<p>Unlike the <seemfa marker="#send/2"><c>send</c></seemfa> function,
	this one sends <em>one message</em>.
	This means that if, for whatever reason, its not possible to send the
	message in one go, the function will instead return with the
	<em>remaining</em> data (<c>{ok, Remaining}</c>). Thereby leaving it
	up to the caller to decide what to do (retry with the remaining data
	of give up). </p>

      </desc>
    </func>

    <func>
      <name name="sendmsg" arity="3" clause_i="2" anchor="sendmsg_async" since="OTP 22.1"/>
      <name name="sendmsg" arity="4" clause_i="1" since="OTP 22.1"/>
      <fsummary>Send a message on a socket.</fsummary>
      <desc>
	<p>Send a message on a socket. The destination, if needed
	(socket <em>not</em> connected) is provided in the <c>MsgHdr</c>,
	which also contains the message to send,
	The <c>MsgHdr</c> may also contain an list of optional <c>cmsghdr_send()</c>
	(depends on what the protocol and platform supports).</p>

	<p>Unlike the <seemfa marker="#send/2"><c>send</c></seemfa> function,
	this one sends <em>one message</em>.
	This means that if, for whatever reason, its not possible to send the
	message in one go, the function will instead return with the
	<em>remaining</em> data (<c>{ok, Remaining}</c>). Thereby leaving it
	up to the caller to decide what to do (retry with the remaining data
	of give up). </p>

	<p>
	  In the case when there is no room in the (system-) buffers,
	  the function will return
	  <seetype marker="#select_info"><c>{select, <anno>SelectInfo</anno>}</c></seetype>.
	  The caller will then receive a select message,
	  <c>{'$socket', Socket, select, SelectHandle}</c> (
	  with
	  <seetype marker="socket#select_handle"><c>SelectHandle</c></seetype>
	  from
	  <seetype marker="#select_info">
	    <c><anno>SelectInfo</anno></c>
	  </seetype>
	  ) when there is room for more data
	  A subsequent call to <c>sendmsg/2-4</c> will then send the data.
	</p>
      </desc>
    </func>

    <func>
      <name name="sendto" arity="3" since="OTP 22.0"/>
      <name name="sendto" arity="4" clause_i="1" since="OTP 22.0"/>
      <name name="sendto" arity="4" clause_i="3" since="OTP 22.0"/>
      <name name="sendto" arity="5" clause_i="2" since="OTP 22.0"/>
      <fsummary>Send a message on a socket.</fsummary>
      <desc>
        <p>Send a message on a socket, to the specified destination.</p>
      </desc>
    </func>

    <func>
      <name name="sendto" arity="4" clause_i="2" anchor="sendto_async" since="OTP 22.1"/>
      <name name="sendto" arity="5" clause_i="1" since="OTP 22.1"/>
      <fsummary>Send a message on a socket.</fsummary>
      <desc>
        <p>Send a message on a socket, to the specified destination.</p>

	<p>
	  In the case when there is no room in the (system-) buffers,
	  the function will return
	  <seetype marker="#select_info"><c>{select, <anno>SelectInfo</anno>}</c></seetype>.
	  The caller will then receive a select message,
	  <c>{'$socket', Socket, select, SelectHandle}</c> (
	  with
	  <seetype marker="socket#select_handle"><c>SelectHandle</c></seetype>
	  from
	  <seetype marker="#select_info">
	    <c><anno>SelectInfo</anno></c>
	  </seetype>
	  ) when there is room for more data
	  A subsequent call to <c>sendto/3-5</c> will then send the data.
	</p>
      </desc>
    </func>

    <func>
      <name name="setopt" arity="3" clause_i="1" since="OTP 22.0"/>
      <fsummary>
	Set a socket option in the protocol level <c>otp</c>.
      </fsummary>
      <desc>
        <p>
	  Sets a socket option in the protocol level <c>otp</c>,
	  which is this implementation's level
	  above the OS protocol layers.
	</p>
	<p>
	  See the type
	  <seetype marker="#otp_socket_option">
	    otp_socket_option()
	  </seetype>
	  for a description of the options on this level.
	</p>
      </desc>
    </func>

    <func>
      <name name="setopt" arity="3" clause_i="2" since="OTP 22.0"/>
      <fsummary>
	Set a socket option in one of the OS's protocol levels.
      </fsummary>
      <desc>
        <p>
	  Set a socket option in one of the OS's protocol levels.
	  See the type
	  <seetype marker="#socket_option">socket_option()</seetype>
	  for which options that this implementation knows about,
	  how they are related to option names in the OS,
	  and if there are known pecularities with any of them.
	</p>
	<p>
	  What options are valid depends on what kind of socket it is
	  (<seetype marker="#domain"><c>domain()</c></seetype>,
	  <seetype marker="#type"><c>type()</c></seetype> and
	  <seetype marker="#protocol"><c>protocol()</c></seetype>).
	</p>
	<p>
	  See the
	  <seeguide marker="socket_usage#socket_options">
	    socket options
	  </seeguide>
	  chapter of the users guide for more info.
	</p>
	<note>
	  <p>
	    Not all options are valid, or possible to set,
	    on all platforms.
	    That is, even if "we" support an option;
	    it does not mean that the underlying OS does.
	  </p>
	</note>
      </desc>
    </func>

    <func>
      <!--
	  Backwards compatibility function - remove documentation?
	  Document the Native clause?
      -->
      <name since="OTP 22.0">
	setopt(Socket, Level, Opt, Value) -> ok | {error, Reason}
      </name>
      <fsummary>
	Set a socket protocol option.
      </fsummary>
      <type>
	<v>
	  Socket = <seetype marker="#socket">socket()</seetype>
	</v>
	<v>
	  Value = term()
	</v>
	<v>
	  Reason = <seetype marker="inet#posix">inet:posix()</seetype>
	  | invalid | closed
	</v>
      </type>
      <desc>
	<p>Backwards compatibility function.</p>
        <p>
	  The same as
	  <seemfa marker="#setopt/3">
	    <c>setopt(Socket, {Level, Opt}, Value)</c>
	  </seemfa>
	</p>
      </desc>
    </func>

    <func>
      <name name="setopt_native" arity="3" since="OTP 22.0"/>
      <fsummary>Set a "native" socket option.</fsummary>
      <desc>
        <p>
	  Sets a socket option that may be unknown to our
	  implementation, or that has a type not compatible
	  with our implementation, that is; in "native mode".
	</p>
	<p>
	  If <c><anno>Value</anno></c> is an <c>integer()</c>
	  it will be used as a <c>C</c> type <c>(int)</c>,
	  if it is a <c>boolean()</c> it will be used
	  as a <c>C</c> type <c>(int)</c> with the <c>C</c>
	  implementations values for <c>false</c> or <c>true</c>,
	  and if it is a <c>binary()</c> its content and size
	  will be used as the option value.
	</p>
	<p>
	  The socket option may be specified with an ordinary
	  <seetype marker="#socket_option">
	    <c>socket_option()</c>
	  </seetype>
	  tuple, with a known 
	  <seetype marker="#sockopt_level">
	    <c><anno>Level</anno> = sockopt_level()</c>
	  </seetype>
	  and an integer <c><anno>NativeOpt</anno></c>,
	  or with both an integer <c><anno>NativeLevel</anno></c>
	  and <c><anno>NativeOpt</anno></c>.
	</p>
	<p>
	  What options are valid depends on what kind of socket it is
	  (<seetype marker="#domain"><c>domain()</c></seetype>,
	  <seetype marker="#type"><c>type()</c></seetype> and
	  <seetype marker="#protocol"><c>protocol()</c></seetype>).
	</p>
	<p>
	  The integer values for 
	  <c><anno>NativeLevel</anno></c> and
	  <c><anno>NativeOpt</anno></c>
	  as well as the encoding of <c><anno>Value</anno></c>
	  has to be deduced from the header files for
	  the running system.
	</p>
      </desc>
    </func>

    <func>
      <name name="shutdown" arity="2" since="OTP 22.0"/>
      <fsummary>Shut down part of a full-duplex connection.</fsummary>
      <desc>
        <p>Shut down all or part of a full-duplex connection.</p>
      </desc>
    </func>

    <func>
      <name name="sockname" arity="1" since="OTP 22.0"/>
      <fsummary>Get socket name.</fsummary>
      <desc>
        <p>Returns the current address to which the socket is bound.</p>
      </desc>
    </func>

    <func>
      <name name="supports" arity="0" since="OTP 22.0"/>
      <name name="supports" arity="1" since="OTP 22.0"/>
      <name name="supports" arity="2" since="OTP 22.0"/>
      <fsummary>Report info about what the platform supports.</fsummary>
      <desc>
	<p>
	  These functions function retreives information about what the
	  platform supports, such which platform features
	  or which socket options, are supported.
	</p>
	<p>
	  For keys other than the known the empty list is returned,
	  Note that in a future version or on a different platform
	  there might be more supported items.
	</p>
	<taglist>
	  <tag><c>supports()</c></tag>
	  <item>
 	    <p>
	      Returns a list of
	      <c>{<anno>Key1</anno>, Supports}</c> tuples
	      for every <c><anno>Key1</anno></c> described below
	      with <c>Supports</c> containing the result of
	      <c>supports(<anno>Key1</anno>, <anno>Key2</anno>)</c>,
	      and a <c>boolean()</c> for each of these keys:
	    </p>
	    <taglist>
	      <tag><c>sctp</c></tag>
	      <item>SCTP support</item>
	      <tag><c>ipv6</c></tag>
	      <item>IPv6 support</item>
	      <tag><c>local</c></tag>
	      <item>
		Unix Domain sockets support (<c>AF_UNIX | AF_LOCAL</c>)
	      </item>
	      <tag><c>netns</c></tag>
	      <item>
		Network Namespaces support (Linux, <c>setns(2)</c>)
	      </item>
	    </taglist>
	  </item>
	  <tag><c>supports(send_flags = <anno>Key1</anno>)</c></tag>
	  <item>
	    <p>
	      Returns a list of 
	      <c>{SendFlag, boolean()}</c> tuples
	      for every <c>SendFlag</c> in
	      <seetype marker="#send_flag">
		<c>send_flag()</c>
	      </seetype>
	      with the <c>boolean()</c> indicating if the flag
	      is supported on this platform.
 	    </p>
	  </item>
	  <tag><c>supports(recv_flags = <anno>Key1</anno>)</c></tag>
	  <item>
 	    <p>
	      Returns a list of 
	      <c>{RecvFlag, boolean()}</c> tuples
	      for every <c>RecvFlag</c> in
	      <seetype marker="#recv_flag">
		<c>recv_flag()</c>
	      </seetype>
	      with the <c>boolean()</c> indicating if the flag
	      is supported on this platform.
	    </p>
	  </item>
	  <tag><c>supports(protocols = <anno>Key1</anno>)</c></tag>
	  <item>
 	    <p>
	      Returns a list of 
	      <c>{Name :: atom(), boolean()}</c> tuples
	      for every <c>Name</c> in
	      <seetype marker="#protocol">
		<c>protocol()</c>
	      </seetype>
	      with the <c>boolean()</c> indicating if the protocol
	      is supported on this platform.
	    </p>
	  </item>
	  <tag><c>supports(options = <anno>Key1</anno>)</c></tag>
	  <item>
	    <p>
	      Returns a list of
	      <c>{<anno>Key2</anno>, Supports}</c> tuples
	      for every <c><anno>Key2</anno></c> in
	      <seetype marker="#sockopt_level">
		<c>sockopt_level()</c>
	      </seetype>
	      with <c>Supports</c> containing the result of
	      <c>supports(options, <anno>Key2</anno>)</c>.
 	    </p>
	  </item>
	  <tag>
	    <c>
	      supports(options = <anno>Key1</anno>, <anno>Key2</anno>)
	    </c>
	  </tag>
	  <item>
	    <p>
	      For a <c><anno>Key2</anno></c> in
	      <seetype marker="#sockopt_level">
		<c>sockopt_level()</c>
	      </seetype>
	      returns a list of <c>{Opt, boolean()}</c> tuples
	      for all known socket options <c>Opt</c> on that level,
	      and the <c>boolean()</c> indicating if the socket option
	      is supported on this platform.
	      See <seemfa marker="#setopt/3">setopt/3</seemfa>
	      and <seemfa marker="#getopt/2">getopt/2</seemfa>.
	    </p>
	  </item>
	</taglist>
      </desc>
    </func>

    <func>
      <name name="use_registry" arity="1" since="OTP @OTP-16763@"/>
      <fsummary>Globally change the use of the socket registry.</fsummary>
      <desc>
	<p>Globally change if the socket registry is to be used or not.
	Note that its still possible to override this explicitly when
	creating an individual sockets,
	see
	<seemfa marker="socket#open/2"><c>open/2</c></seemfa>
	or
	<seemfa marker="socket#open/4"><c>open/4</c></seemfa>
	for more info (use the Extra argument). </p>
      </desc>
    </func>

    <func>
      <name name="which_sockets" arity="0" since="OTP 22.3"/>
      <name name="which_sockets" arity="1" since="OTP 22.3"/>
      <fsummary>Get the current active sockets.</fsummary>
      <desc>
	<p>Returns a list of all sockets, according to the
	filter rule.</p>
	<p>There are several pre-made filter rule(s) and one general: </p>
	<taglist>
	  <tag><c><![CDATA[inet | inet6]]></c></tag>
	  <item>
	    <p>Selection based on the domain of the socket.
	    <br/>Only a subset is valid. </p>
	  </item>

	  <tag><c><![CDATA[stream | dgram | seqpacket]]></c></tag>
	  <item>
	    <p>Selection based on the type of the socket.
	    <br/>Only a subset is valid. </p>
	  </item>

	  <tag><c><![CDATA[sctp | tcp | udp]]></c></tag>
	  <item>
	    <p>Selection based on the protocol of the socket.
	    <br/>Only a subset is valid. </p>
	  </item>

	  <tag><c><![CDATA[pid()]]></c></tag>
	  <item>
	    <p>Selection base on which sockets has this pid as
	    Controlling Process. </p>
	  </item>

	  <tag><c><![CDATA[fun((socket_info()) -> boolean())]]></c></tag>
	  <item>
	    <p>The general filter rule.
	    <br/>A fun that takes the socket info and returns a
	    <c><![CDATA[boolean()]]></c>
	    (<c><![CDATA[true]]></c> if the socket sould be included and
	    <c><![CDATA[false]]></c> if should not). </p>
	  </item>
	</taglist>
      </desc>
    </func>

  </funcs>
  <section>
    <title>Examples</title>
    <marker id="examples"></marker>
    <code type="none">
client(Addr, SAddr, SPort) ->
   {ok, Sock} = socket:open(inet, stream, tcp),
   {ok, _} = socket:bind(Sock, #{family => inet,
                                 addr   => Addr}),
   ok = socket:connect(Sock, #{family => inet,
                               addr   => SAddr,
			       port   => SPort}),
   Msg = list_to_binary("hello"),
   ok = socket:send(Sock, Msg),
   ok = socket:shutdown(Sock, write),
   {ok, Msg} = socket:recv(Sock),
   ok = socket:close(Sock).

server(Addr, Port) ->  
   {ok, LSock} = socket:open(inet, stream, tcp),
   {ok, _} = socket:bind(LSock, #{family => inet,
                                  port   => Port,
		 	          addr   => Addr}),
   ok = socket:listen(LSock),
   {ok, Sock} = socket:accept(LSock),
   {ok, Msg} = socket:recv(Sock),
   ok = socket:send(Sock, Msg),
   ok = socket:shutdown(Sock, write),
   ok = socket:close(Sock),
   ok = socket:close(LSock).
    </code>
  </section>
</erlref>
