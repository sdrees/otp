#!/usr/bin/env escript
%% -*- erlang -*-

%%
%% %CopyrightBegin%
%%
%% Copyright Ericsson AB 2020. All Rights Reserved.
%%
%% Licensed under the Apache License, Version 2.0 (the "License");
%% you may not use this file except in compliance with the License.
%% You may obtain a copy of the License at
%%
%%     http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing, software
%% distributed under the License is distributed on an "AS IS" BASIS,
%% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
%% See the License for the specific language governing permissions and
%% limitations under the License.
%%
%% %CopyrightEnd%
%%

-mode(compile).

-import(lists, [foldl/3,sort/1]).

-record(st, { functions = [], types = [] }).

main([_|_]=Directories) ->
    emit(summarize(Directories)),
    halt(0).

summarize(Directories) ->
    foldl(fun summarize_directory/2, #st{}, Directories).

summarize_directory(Dir, Acc) ->
    Files = [filename:join(Dir, F) || F <- filelib:wildcard("*.beam", Dir)],
    foldl(fun summarize_file/2, Acc, Files).

summarize_file(File, Acc) ->
    {ok, {Module, [Chunk]}} = beam_lib:chunks(File, [attributes]),
    {attributes, Attributes} = Chunk,
    summarize_attributes(Attributes, Module, Acc).

summarize_attributes([{deprecated, Ds} | As], Module, Acc0) ->
    Fs = sa_1(Ds, deprecated, Module, Acc0#st.functions),
    Acc = Acc0#st{ functions = Fs },
    summarize_attributes(As, Module, Acc);
summarize_attributes([{removed, Rs} | As], Module, Acc0) ->
    Fs = sa_1(Rs, removed, Module, Acc0#st.functions),
    Acc = Acc0#st{ functions = Fs },
    summarize_attributes(As, Module, Acc);
summarize_attributes([{deprecated_type, Ds} | As], Module, Acc0) ->
    Ts = sa_1(Ds, deprecated, Module, Acc0#st.types),
    Acc = Acc0#st{ types = Ts },
    summarize_attributes(As, Module, Acc);
summarize_attributes([{removed_type, Rs} | As], Module, Acc0) ->
    Ts = sa_1(Rs, removed, Module, Acc0#st.types),
    Acc = Acc0#st{ types = Ts },
    summarize_attributes(As, Module, Acc);
summarize_attributes([_ | As], Module, Acc) ->
    summarize_attributes(As, Module, Acc);
summarize_attributes([], _Module, Acc) ->
    Acc.

sa_1([{F, A, Info} | As], Tag, Module, Acc0) ->
    sa_1(As, Tag, Module, [{Tag, Module, F, A, Info} | Acc0]);
sa_1([{F, A} | As], Tag, Module, Acc0) ->
    sa_1(As, Tag, Module, [{Tag, Module, F, A, undefined} | Acc0]);
sa_1([module | As], Tag, Module, Acc0) ->
    sa_1(As, Tag, Module, [{Tag, Module, '_', '_', undefined} | Acc0]);
sa_1([], _Tag, _Module, Acc) ->
    Acc.

%%

emit(#st{ functions = Fs, types = Ts }) ->
    io:format("%%\n"
              "%% WARNING: DO NOT EDIT THIS FILE.\n"
              "%%\n"
              "%% This file was auto-generated from attributes in the source\n"
              "%% code.\n"
              "%%\n"
              "%% To add a description to a deprecation or removal attribute,\n"
              "%% write a string after the arity:\n"
              "%%\n"
              "%%    -deprecated([{foo,1,\"use bar/1 instead\"}]).\n"
              "%%    -deprecated_type([{gadget,1,\"use widget/1 instead\"}]).\n"
              "%%    -removed([{hello,2,\"use there/2 instead\"}]).\n"
              "%%    -removed_type([{frobnitz,1,\"use grunka/1 instead\"}]).\n"
              "%%\n"
              "%% Descriptions cannot be given with the `f/1` shorthand, and\n"
              "%% it will fall back to a generic description referring the\n"
              "%% user to the documentation.\n"
              "%%\n"
              "%% Use `./otp_build update_deprecations` to update this file\n"
              "%% after adding an attribute.\n"
              "%%\n"
              "-module(otp_internal).\n"
              "-include(\"otp_internal.hrl\").\n"
              "%%\n"),

    emit_function("obsolete", Fs),
    emit_function("obsolete_type", Ts),

    ok.

emit_function(FuncName, Entries) ->
    io:format("-dialyzer({no_match, ~ts/3}).\n", [FuncName]),
    [emit_clause(FuncName, E) || E <- sort_clauses(Entries)],

    io:format("~ts(_,_,_) -> no.\n\n", [FuncName]).

sort_clauses(Entries) ->
    Tagged = [{clause_order(E), E} || E <- Entries],
    [E || {_, E} <- sort(Tagged)].

%% Wildcard matches must be emitted *after* specific matches to avoid
%% losing descriptions.
clause_order({_Tag, _Module, F, A, _Info}) when F =/= '_', A =/= '_' -> 0;
clause_order({_Tag, _Module, F, '_', _Info}) when F =/= '_' -> 1;
clause_order({_Tag, _Module, '_', A, _Info}) when A =/= '_' -> 2;
clause_order({_Tag, _Module, '_', '_', _Info}) -> 3.

emit_clause(FuncName, {Tag, M, F, A, Info}) ->
    io:format("~ts(~ts, ~ts, ~ts) ->\n"
              "    {~p, ~p};\n",
              [FuncName, match_string(M), match_string(F), match_string(A),
               Tag, info_string(Info)]).

%%

info_string(undefined) ->
    "see the documentation for details";
info_string(next_version) ->
    "will be removed in the next version. "
        "See the documentation for details";
info_string(next_major_release) ->
    "will be removed in the next major release. "
        "See the documentation for details";
info_string(eventually) ->
    "will be removed in a future release. "
        "See the documentation for details";
info_string(String) when is_list(String) ->
    String.

match_string('_') -> "_";
match_string(Term) -> io_lib:format("~p", [Term]).
